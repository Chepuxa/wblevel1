package main

import (
	"fmt"
	"sync"
	"time"
)

/*
Вопрос: Чем отличаются RWMutex от Mutex?

Ответ:
Обычный Mutex однозначно блокирует доступ к ресурсу и может быть всего в двух состояниях - 0 (мьютекс разблокирован) или 1 (мьютекс заблокирован)
Первый источник, вызвавший Lock(), заблокирует мьютекс и доступ к ресурсу, и остальные источники будут ждать его разблокировки
RWMutex (Read-Write Mutex) работает по другому принципу:
	- Вызвать RLock() и получить доступ к ресурсу могут несколько источников R, не блокируя работу друг-друга
	- Когда источник W вызывает Lock(), последующие источники R, вызывающие RLock() будут заблокированы, а сам W будет дожидаться вызова активными источниками R метода RUnlock()
		 (т.е. окончания работы с ресурсом). Также будет заблокирован доступ другим источникам W, вызывающим Lock(), через вызов метода Lock() стандартного мьютекса
	- Когда все активные источники R вызовут RUnlock(), источник W получит доступ к ресурсу, вызывая Unlock() после окончания работы с ресурсом
	- После вызова Unlock(), все источники R, заблокированные ранее, получат доступ к ресурсу, откроется доступ к ресурсу всем последующим источникам R, вызывающим RUnlock(),
		 и вызовется Unlock() обычного мьютекса, открывая доступ последующим источникам W
Таким образом, RWMutex предоставляет доступ нескольим источникам R или только одному источнику W
Ниже представлен пример использования RWMutex для предоставления доступа к чтению и изменению переменной в разных горутинах
Числа будут выводиться в stdout "пачками", т.к. читающие потоки прерываются на ожидание пишущего потока, после чего выполняются с уже обновленными данными
*/

type Doc struct {
	mx sync.RWMutex
	i int
}

func NewDoc() *Doc {
	return &Doc{}
}

func main() {
	d := NewDoc()
	var wg sync.WaitGroup
	wg.Add(2)

	d.Write("a", 1)

	for i := 0; i < 10; i++ {
		go func() {
			for {
				fmt.Println(d.Get("a"))
			}
		}()
	}

	go func() {
		i := 2
		for {
			d.Write("a", i)
			i++
		}
	}()

	wg.Wait()
}

func (d *Doc) Get(s string) int {
	d.mx.RLock()
	defer d.mx.RUnlock()
	return d.i
}

func (d *Doc) Write(s string, n int) {
	d.mx.Lock()
	defer d.mx.Unlock()
	time.Sleep(2 * time.Second)
	d.i = n
}